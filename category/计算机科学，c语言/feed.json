{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo • All posts by \"计算机科学，c语言\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/computer-science/c/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "url": "http://example.com/computer-science/c/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "title": "动态规划",
            "date_published": "2022-10-24T10:18:10.587Z",
            "content_html": "<h1 id=\"动态规划\"><a class=\"markdownIt-Anchor\" href=\"#动态规划\">#</a> 动态规划</h1>\n<h2 id=\"入门\"><a class=\"markdownIt-Anchor\" href=\"#入门\">#</a> 入门</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<p>​\t动态规划是我们运用算法解决问题的一种方式，我们可以将它简单的理解成：找递推式。有时我们碰到一个非常复杂的问题，往往可以通过找递推式的方法把他分解成子问题，再将子问题分解成孙问题。。。在有穷次分解后可以得到一个或几个拥有显而易见答案的简单 “后代问题”，程序将上述分解的方法再逆过来执行一遍就能够解决这样的复杂问题。与分而治之不同，动态规划在对问题分解时运用的是找递推式的思想，这意味着分解出的问题相似性很高以至于许多时候我们习惯于直接借助计算机分解问题。而计算机在接下来的步骤中有需要将这些问题逆向加和，因此，不妨在写代码时将这二者合并，最后呈现出的代码反而是先定义基元问题，通过递推式层层向上合成，最终到达一定限度，停止运算。</p>\n<p>​</p>\n<p>如果您感到困惑，我希望下面的题例能够帮助你：</p>\n<h3 id=\"noip2002-普及组-过河卒\"><a class=\"markdownIt-Anchor\" href=\"#noip2002-普及组-过河卒\">#</a> [NOIP2002 普及组] 过河卒</h3>\n<h4 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h4>\n<p>棋盘上 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 点有一个过河卒，需要走到目标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为 “马拦过河卒”。</p>\n<p>棋盘用坐标表示，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(0, 0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n, m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，同样马的位置坐标是需要给出的。</p>\n<p><img data-src=\"https://cdn.luogu.com.cn/upload/image_hosting/vg6k477j.png\" alt=\"\"></p>\n<p>现在要求你计算出卒从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 点能够到达 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p>\n<h4 id=\"输入格式\"><a class=\"markdownIt-Anchor\" href=\"#输入格式\">#</a> 输入格式</h4>\n<p>一行四个正整数，分别表示 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 点坐标和马的坐标。</p>\n<h4 id=\"输出格式\"><a class=\"markdownIt-Anchor\" href=\"#输出格式\">#</a> 输出格式</h4>\n<p>一个整数，表示所有的路径条数。</p>\n<h4 id=\"样例-1\"><a class=\"markdownIt-Anchor\" href=\"#样例-1\">#</a> 样例 #1</h4>\n<p>样例输入 #1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">6 6 3 3<br></code></pre></td></tr></table></figure>\n<p>样例输出 #1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">6<br></code></pre></td></tr></table></figure>\n<h4 id=\"提示\"><a class=\"markdownIt-Anchor\" href=\"#提示\">#</a> 提示</h4>\n<p>对于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>100</mn><mi mathvariant=\"normal\">%</mi></mrow><annotation encoding=\"application/x-tex\">100 \\%</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80556em;vertical-align:-0.05556em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">%</span></span></span></span> 的数据，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">1 \\le n, m \\le 20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">0 \\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span></span></span></span> 马的坐标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">\\le 20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span>。</p>\n<p><strong>【题目来源】</strong></p>\n<p>NOIP 2002 普及组第四题</p>\n<h4 id=\"分析\"><a class=\"markdownIt-Anchor\" href=\"#分析\">#</a> 分析</h4>\n<ol>\n<li>\n<p>这是一个经典的动态规划问题 —— 统计路径条数。我们可以直观的感受到，即使添加了只能向下或向右的限制，统计到达某一点所有路径的方案也并不容易，这是一个极为复杂的问题，并且随着你标点于原点的距离越来越远，工程将会越来越大。不过，如果将这个问题交给动态规划，事情瞬间就会变得清晰明了。</p>\n<ol>\n<li>对于某一点 (<em>i</em>,<em>j</em>)，设函数<em> f</em>(<em>i</em>,<em>j</em>) 为从原点到这一点的所有路径数，不难找到他的递推式之一即为:</li>\n<li>得到了这样的递推式后，我们自然想要将这样的递推式写在程序里。我们如何储存这样的递推式呢？或许你的第一反应是去想办法写出类似的递归函数，然后寻找某个边界值。这样的思路自然是最简单的，但也是最危险的。不妨设想一下，如果将 i 语 j 的数字设置的很大 —— 也许不需要很大，甚至二十几就足够让这样的函数无穷的递归中反反复复 —— 并且他们所计算的值甚至非常相似。</li>\n<li>事实上，通常的做法是，我们往往会使用一串数组去存储函数 f (i,j) 的所有因变量 —— 这取决于传入的 i 和 j 的大小。这样的好处是，当我们去使用递推式的时候，我们不用从新进行一次递归，而是取用已经递归出的结果。这样不仅占用空间较少，而且能让你的程序可运行。</li>\n<li>当然，使用数组定义的函数还存在许多问题。在这一题中，我们就必须为了保证不会出现 f (-1,0) 的情况将所有传入的坐标被迫加 1。</li>\n<li>最后，设置一个初始的基元，比如 f (0,1)=1，使用循环顺序遍历数组，将将函数值通过递推式计算后一一填入即可。</li>\n</ol>\n</li>\n<li>\n<p>在解决了路径统计之后，我们面临的问题就是：如何将马控制点去除？事实上，如果你很好的理解了上面的叙述，将马去除这件事再简单不过了：</p>\n<ol>\n<li>将马控制点去除，我们只需要让 f (xm,ym)=0，也就是说能够达到马控制点的路径一个都没有加到上述的递推式中即可。</li>\n<li>找出所有 xm 与 ym 也非常简单，因为你很容易就能发现这些点与给出的马的坐标的距离为定值。我们只需要在遍历数组是添加一个判断即可。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"参考代码\"><a class=\"markdownIt-Anchor\" href=\"#参考代码\">#</a> 参考代码</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ll long long</span><br>ll <span class=\"hljs-title function_\">lujingshu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span>;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> <br>&#123;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> result;<br>\t<span class=\"hljs-type\">int</span> bx, by, mx, my;<br>\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d%d%d%d&quot;</span>, &amp;bx, &amp;by, &amp;mx, &amp;my);<br>\tresult = lujingshu(bx, by, mx, my);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%lld&quot;</span>, result);<br>&#125;<br><br>ll <span class=\"hljs-title function_\">lujingshu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> mx, <span class=\"hljs-type\">int</span> my)</span><br>&#123;<br>\tll r = <span class=\"hljs-number\">0</span>;<br>\tx++;<br>\ty++;<br>\tmx++;<br>\tmy++;<br>\tll f[<span class=\"hljs-number\">22</span>][<span class=\"hljs-number\">22</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>\tf[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= x; i++) <br>    &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= y; j++) <br>        &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (((i - mx) * (i - mx) + (j - my) * (j - my) == <span class=\"hljs-number\">5</span> ) || (i == mx &amp;&amp; j == my)) &#123;<br>\t\t\t\tf[i][j] = <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>            <span class=\"hljs-keyword\">else</span> <br>            &#123;<br>\t\t\t\tf[i][j] = f[i][j - <span class=\"hljs-number\">1</span>] + f[i - <span class=\"hljs-number\">1</span>][j];<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\tr = f[x][y];<br>\t<span class=\"hljs-keyword\">return</span> r;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n",
            "tags": []
        }
    ]
}