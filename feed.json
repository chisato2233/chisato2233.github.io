{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/computer-science/c/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "url": "http://example.com/computer-science/c/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "title": "动态规划",
            "date_published": "2022-10-24T10:18:10.587Z",
            "content_html": "<h1 id=\"动态规划\"><a class=\"markdownIt-Anchor\" href=\"#动态规划\">#</a> 动态规划</h1>\n<h2 id=\"入门\"><a class=\"markdownIt-Anchor\" href=\"#入门\">#</a> 入门</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<p>​\t动态规划是我们运用算法解决问题的一种方式，我们可以将它简单的理解成：找递推式。有时我们碰到一个非常复杂的问题，往往可以通过找递推式的方法把他分解成子问题，再将子问题分解成孙问题。。。在有穷次分解后可以得到一个或几个拥有显而易见答案的简单 “后代问题”，程序将上述分解的方法再逆过来执行一遍就能够解决这样的复杂问题。与分而治之不同，动态规划在对问题分解时运用的是找递推式的思想，这意味着分解出的问题相似性很高以至于许多时候我们习惯于直接借助计算机分解问题。而计算机在接下来的步骤中有需要将这些问题逆向加和，因此，不妨在写代码时将这二者合并，最后呈现出的代码反而是先定义基元问题，通过递推式层层向上合成，最终到达一定限度，停止运算。</p>\n<p>​</p>\n<p>如果您感到困惑，我希望下面的题例能够帮助你：</p>\n<h3 id=\"noip2002-普及组-过河卒\"><a class=\"markdownIt-Anchor\" href=\"#noip2002-普及组-过河卒\">#</a> [NOIP2002 普及组] 过河卒</h3>\n<h4 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h4>\n<p>棋盘上 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 点有一个过河卒，需要走到目标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为 “马拦过河卒”。</p>\n<p>棋盘用坐标表示，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(0, 0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n, m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，同样马的位置坐标是需要给出的。</p>\n<p><img data-src=\"https://cdn.luogu.com.cn/upload/image_hosting/vg6k477j.png\" alt=\"\"></p>\n<p>现在要求你计算出卒从 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 点能够到达 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p>\n<h4 id=\"输入格式\"><a class=\"markdownIt-Anchor\" href=\"#输入格式\">#</a> 输入格式</h4>\n<p>一行四个正整数，分别表示 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 点坐标和马的坐标。</p>\n<h4 id=\"输出格式\"><a class=\"markdownIt-Anchor\" href=\"#输出格式\">#</a> 输出格式</h4>\n<p>一个整数，表示所有的路径条数。</p>\n<h4 id=\"样例-1\"><a class=\"markdownIt-Anchor\" href=\"#样例-1\">#</a> 样例 #1</h4>\n<p>样例输入 #1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">6 6 3 3<br></code></pre></td></tr></table></figure>\n<p>样例输出 #1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">6<br></code></pre></td></tr></table></figure>\n<h4 id=\"提示\"><a class=\"markdownIt-Anchor\" href=\"#提示\">#</a> 提示</h4>\n<p>对于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>100</mn><mi mathvariant=\"normal\">%</mi></mrow><annotation encoding=\"application/x-tex\">100 \\%</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80556em;vertical-align:-0.05556em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">%</span></span></span></span> 的数据，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">1 \\le n, m \\le 20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304100000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">0 \\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span></span></span></span> 马的坐标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">\\le 20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span>。</p>\n<p><strong>【题目来源】</strong></p>\n<p>NOIP 2002 普及组第四题</p>\n<h4 id=\"分析\"><a class=\"markdownIt-Anchor\" href=\"#分析\">#</a> 分析</h4>\n<ol>\n<li>\n<p>这是一个经典的动态规划问题 —— 统计路径条数。我们可以直观的感受到，即使添加了只能向下或向右的限制，统计到达某一点所有路径的方案也并不容易，这是一个极为复杂的问题，并且随着你标点于原点的距离越来越远，工程将会越来越大。不过，如果将这个问题交给动态规划，事情瞬间就会变得清晰明了。</p>\n<ol>\n<li>对于某一点 (<em>i</em>,<em>j</em>)，设函数<em> f</em>(<em>i</em>,<em>j</em>) 为从原点到这一点的所有路径数，不难找到他的递推式之一即为:</li>\n<li>得到了这样的递推式后，我们自然想要将这样的递推式写在程序里。我们如何储存这样的递推式呢？或许你的第一反应是去想办法写出类似的递归函数，然后寻找某个边界值。这样的思路自然是最简单的，但也是最危险的。不妨设想一下，如果将 i 语 j 的数字设置的很大 —— 也许不需要很大，甚至二十几就足够让这样的函数无穷的递归中反反复复 —— 并且他们所计算的值甚至非常相似。</li>\n<li>事实上，通常的做法是，我们往往会使用一串数组去存储函数 f (i,j) 的所有因变量 —— 这取决于传入的 i 和 j 的大小。这样的好处是，当我们去使用递推式的时候，我们不用从新进行一次递归，而是取用已经递归出的结果。这样不仅占用空间较少，而且能让你的程序可运行。</li>\n<li>当然，使用数组定义的函数还存在许多问题。在这一题中，我们就必须为了保证不会出现 f (-1,0) 的情况将所有传入的坐标被迫加 1。</li>\n<li>最后，设置一个初始的基元，比如 f (0,1)=1，使用循环顺序遍历数组，将将函数值通过递推式计算后一一填入即可。</li>\n</ol>\n</li>\n<li>\n<p>在解决了路径统计之后，我们面临的问题就是：如何将马控制点去除？事实上，如果你很好的理解了上面的叙述，将马去除这件事再简单不过了：</p>\n<ol>\n<li>将马控制点去除，我们只需要让 f (xm,ym)=0，也就是说能够达到马控制点的路径一个都没有加到上述的递推式中即可。</li>\n<li>找出所有 xm 与 ym 也非常简单，因为你很容易就能发现这些点与给出的马的坐标的距离为定值。我们只需要在遍历数组是添加一个判断即可。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"参考代码\"><a class=\"markdownIt-Anchor\" href=\"#参考代码\">#</a> 参考代码</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ll long long</span><br>ll <span class=\"hljs-title function_\">lujingshu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span>;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> <br>&#123;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> result;<br>\t<span class=\"hljs-type\">int</span> bx, by, mx, my;<br>\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d%d%d%d&quot;</span>, &amp;bx, &amp;by, &amp;mx, &amp;my);<br>\tresult = lujingshu(bx, by, mx, my);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%lld&quot;</span>, result);<br>&#125;<br><br>ll <span class=\"hljs-title function_\">lujingshu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> mx, <span class=\"hljs-type\">int</span> my)</span><br>&#123;<br>\tll r = <span class=\"hljs-number\">0</span>;<br>\tx++;<br>\ty++;<br>\tmx++;<br>\tmy++;<br>\tll f[<span class=\"hljs-number\">22</span>][<span class=\"hljs-number\">22</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>\tf[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= x; i++) <br>    &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= y; j++) <br>        &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (((i - mx) * (i - mx) + (j - my) * (j - my) == <span class=\"hljs-number\">5</span> ) || (i == mx &amp;&amp; j == my)) &#123;<br>\t\t\t\tf[i][j] = <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>            <span class=\"hljs-keyword\">else</span> <br>            &#123;<br>\t\t\t\tf[i][j] = f[i][j - <span class=\"hljs-number\">1</span>] + f[i - <span class=\"hljs-number\">1</span>][j];<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\tr = f[x][y];<br>\t<span class=\"hljs-keyword\">return</span> r;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<h2 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h2>\n",
            "tags": []
        },
        {
            "id": "http://example.com/games/yuansheng/%E5%8E%9F%E5%9C%A3%E5%9F%BA%E6%9C%AC%E4%BD%93%E7%B3%BB%E8%AF%B4%E6%98%8E01/",
            "url": "http://example.com/games/yuansheng/%E5%8E%9F%E5%9C%A3%E5%9F%BA%E6%9C%AC%E4%BD%93%E7%B3%BB%E8%AF%B4%E6%98%8E01/",
            "title": "原圣基本规则体系说明",
            "date_published": "2022-10-17T04:40:39.105Z",
            "content_html": "<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>原圣是基于原神和三国杀结合的卡牌对战类游戏，体系主体为原神和三国杀的基本规则，因此在阅读本体系说明之前，作者建议对上述两款游戏不了解的读者尝试花费二十分钟初步掌握基本名词与概念，受限于篇幅，某些方面作者可能不会过分详细的指明。</p>\n<p><u>我们强烈建议读者不要在对于三国杀和原神基本规则一知半解的前提下阅读正文。</u></p>\n<h1 id=\"元素\"><a class=\"markdownIt-Anchor\" href=\"#元素\">#</a> 元素</h1>\n<h2 id=\"元素种类\"><a class=\"markdownIt-Anchor\" href=\"#元素种类\">#</a> 元素种类</h2>\n<ul>\n<li>与原神对应的，本游戏所使用的元素种类同样为 &quot;火水冰雷草岩风&quot; 七种。</li>\n<li>原圣中的每个元素都映射实体牌中的一种属性。这些元素依照下面的规则做映射：</li>\n</ul>\n<p>​\t\t\t\t\t\t火   \t\t\t\t\t红桃 [花色]<br>\n​\t\t\t\t\t\t水   \t\t\t\t\t梅花 [花色]<br>\n​\t\t\t\t\t\t冰   \t\t\t\t\t方片 [花色]<br>\n​\t\t\t\t\t\t雷   \t\t\t\t\t黑桃 [花色]<br>\n​\t\t\t\t\t\t草   \t\t\t\t\tA~4 [点数]<br>\n​\t\t\t\t\t\t风   \t\t\t\t\t5~8 [点数]<br>\n​\t\t\t\t\t\t岩   \t\t\t\t\t9~K [点数]</p>\n<ul>\n<li>诸如上述的映射具有这样的意义：\n<ol>\n<li>在角色试图触发技能时，他们所需要用于支付代价的牌会根据他们的所属元素而限定在某一类之上，如此以便于通过控制牌堆结构进一步控制某种元素的整体角色强度。</li>\n<li>方便进行元素附着时的判断。(这一点的本意会在 1.2 小节会具体告知读者)</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>原圣规则体系不会删除和增加任何元素 —— 除非原神官方明确对于元素种类方面做出改动。</li>\n</ul>\n<h2 id=\"元素伤害\"><a class=\"markdownIt-Anchor\" href=\"#元素伤害\">#</a> 元素伤害</h2>\n<h3 id=\"物理伤害\"><a class=\"markdownIt-Anchor\" href=\"#物理伤害\">#</a> 物理伤害</h3>\n<p>本小节的名称虽然为 &quot;元素伤害&quot;，但是三国杀与原神中的 &quot;非元素伤害&quot; 定义有所不同，规则集没有必要特别的建立一个小节阐明 &quot;非元素伤害&quot; 的性质，因此将其归入本小节中</p>\n<ul>\n<li>物理伤害在游戏中出现频率极低，方便起见，在任何场合下单独出现的名词 &quot;伤害&quot;，均等效替换为 &quot;元素伤害&quot;。</li>\n<li>由于目前原神中未出现单角色能够触发多种元素伤害的前提，因此在角色技能描述的场合下出现的 &quot;元素伤害&quot; 均替换为与该角色同名的 &quot;X 元素伤害&quot;。</li>\n<li>在极个别场合下为了统称 &quot;物理伤害&quot; 与 &quot;元素伤害&quot;，我们将包含二者的集合称为 &quot;宏伤害&quot;。</li>\n</ul>\n<h3 id=\"元素伤害-2\"><a class=\"markdownIt-Anchor\" href=\"#元素伤害-2\">#</a> 元素伤害</h3>\n<ul>\n<li>元素伤害的种类与元素种类一一对应，在此本文不再赘述</li>\n<li>元素伤害与元素附着是两个独立概念，在原圣的某些场合下会出现受到元素伤害的同时触发反应，因此可能会给某些玩家产生误解，在此特别强调</li>\n</ul>\n<h2 id=\"元素附着\"><a class=\"markdownIt-Anchor\" href=\"#元素附着\">#</a> 元素附着</h2>\n<h3 id=\"元素附着区\"><a class=\"markdownIt-Anchor\" href=\"#元素附着区\">#</a> 元素附着区</h3>\n<ul>\n<li>元素附着区是原圣中特有的区域，替换了三国杀中的判定区，此区域用于存放角色的当前元素附着，方便起见，后文中简称的 &quot;元素区&quot; 代指元素附着区</li>\n<li>元素区有这样的性质：\n<ol>\n<li>同名元素附着最多存在两张，后手附着叠放于先手附着之上</li>\n<li>回合结束时，清空元素区所有竖置的元素附着</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"附着牌\"><a class=\"markdownIt-Anchor\" href=\"#附着牌\">#</a> 附着牌</h3>\n<ul>\n<li>附着牌是原圣中的一种特有概念，附着牌是一种可以进行附着的牌，他用于提示玩家一名角色的元素附着状态。</li>\n<li>为保证叙述的流畅性，我们会在一些场合在不产生歧义的前提下，将附着牌与元素附着等价</li>\n<li>玩家可以将手中某张满足映射，且所映射元素种类与角色同名的任意牌当做附着牌。</li>\n</ul>\n<h3 id=\"附着\"><a class=\"markdownIt-Anchor\" href=\"#附着\">#</a> 附着</h3>\n<ul>\n<li>\n<p>附着是原圣中的一种行为，他代指改变角色元素区状态的动作。玩家可以通过下面的方式进行附着行动：</p>\n<p>​\t<u>玩家可以将手中某张满足映射，且所映射元素种类与角色同名的任意牌声明为附着牌。出牌阶段限一次，玩家可以以此方式声明的附着牌竖置入一名其他角色的元素区。</u></p>\n</li>\n<li>\n<p>附着的方式不止一种，角色造成伤害时，某些情况下也可以进行短暂的临时附着。以此法产生的临时附着遵循以下规律：</p>\n<ol>\n<li>\n<p>每名玩家都拥有五条 “附着记录空间”，将他们分别称为 A 空间，B 空间，C 空间，D 空间和 E 空间。</p>\n</li>\n<li>\n<p>每条记录空间最多存放一次临时附着的记录。玩家造成伤害前，会根据规则调用一条指定的记录空间。如果此空间已经被占用，则此次伤害将不会触发临时附着。</p>\n</li>\n<li>\n<p>回合开始时，清空所有记录空间的临时附着记录。玩家造成伤害前，没有特别说明的情况下，进行临时元素附着并将此次附着记录于 A 空间中。某些角色的技能可以调用剩下的四种空间。</p>\n</li>\n<li>\n<p>标明 “独立附着” 的伤害会从 A 空间开始遍历，直到找到空空间为止。</p>\n</li>\n<li>\n<p>成功临时附着的伤害结算完毕后，清空临时附着，因此这种附着不会留存进元素区。</p>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>临时附着的规则拥有下面的更为通俗的解释：</p>\n<ol>\n<li>在通常的状态下，每名角色每轮只能进行一次临时附着。</li>\n<li>某些角色技能可以额外触发临时附着，这种额外触发的附着也只能生效一次。</li>\n<li>带有 “独立附着” 的技能允许角色多次地触发元素附着，这类技能会占用上述两种手段所触发临时附着的次数。</li>\n<li>每名角色每轮最多五次临时附着。</li>\n</ol>\n</blockquote>\n",
            "tags": []
        },
        {
            "id": "http://example.com/genshine-impact/%E5%85%83%E7%B4%A0%E8%AE%BA/",
            "url": "http://example.com/genshine-impact/%E5%85%83%E7%B4%A0%E8%AE%BA/",
            "title": "元素论",
            "date_published": "2022-10-16T13:15:47.887Z",
            "content_html": "<h1 id=\"元素论\"><a class=\"markdownIt-Anchor\" href=\"#元素论\">#</a> 元素论</h1>\n<h2 id=\"第一章绪论\"><a class=\"markdownIt-Anchor\" href=\"#第一章绪论\">#</a> 第一章：绪论</h2>\n<h3 id=\"11-元素简介\"><a class=\"markdownIt-Anchor\" href=\"#11-元素简介\">#</a> 1.1 元素简介</h3>\n",
            "tags": []
        },
        {
            "id": "http://example.com/example/chisato-is-my-wife/",
            "url": "http://example.com/example/chisato-is-my-wife/",
            "title": "练习题与答案",
            "date_published": "2022-10-12T14:39:30.375Z",
            "content_html": "<ol>\n<li class=\"quiz true\">\n<p>编译时多态主要指运算符重载与函数重载，而运行时多态主要指虚函数。</p>\n</li>\n<li class=\"quiz multi\">\n<p>有基类  <code>SHAPE</code> ，派生类  <code>CIRCLE</code> ，声明如下变量： </p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">SHAPE shape1,*p1;<br>CIRCLE circle1,*q1;<br></code></pre></td></tr></table></figure>\n<p>下列哪些项是 “派生类对象替换基类对象”。</p>\n<ul class=\"options\">\n<li class=\"correct\"><code>p1=&amp;circle1;</code> </li>\n<li><code>q1=&amp;shape1;</code></li>\n<li class=\"correct\"><code>shape1=circle1;</code> </li>\n<li><code>circle1=shape1;</code></li>\n</ul>\n<blockquote>\n<ul class=\"options\">\n<li>✔️ 令基类对象的指针指向派生类对象</li>\n<li>❌ 派生类指针指向基类的引用</li>\n<li>✔️ 派生类对象给基类对象赋值</li>\n<li>❌ 基类对象给派生类对象赋值</li>\n</ul>\n</blockquote>\n</li>\n<li class=\"quiz\">\n<p>下列叙述正确的是 <span class=\"gap\"></span> 。</p>\n<ul class=\"options\">\n<li>虚函数只能定义成无参函数</li>\n<li>虚函数不能有返回值</li>\n<li>能定义虚构造函数</li>\n<li class=\"correct\">A、B、C 都不对</li>\n</ul>\n</li>\n<li class=\"quiz fill\">\n<p>如果定义  <code>int e=8; double f=6.4, g=8.9;</code> ，则表达式  <code>f+int (e/3*int (f+g)/2)%4</code>  的值为 <span class=\"gap\">9.4</span>。</p>\n<blockquote>\n<p>注意运算顺序和数据类型<br>\n<span class=\"mistake\"> 8.4</span></p>\n</blockquote>\n</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/example/chisato%E4%B8%96%E7%95%8C%E7%AC%AC%E4%B8%80%E5%8F%AF%E7%88%B1%EF%BC%81%EF%BC%81%EF%BC%81/",
            "url": "http://example.com/example/chisato%E4%B8%96%E7%95%8C%E7%AC%AC%E4%B8%80%E5%8F%AF%E7%88%B1%EF%BC%81%EF%BC%81%EF%BC%81/",
            "title": "chisato世界第一可爱！！！",
            "date_published": "2022-10-12T10:42:08.000Z",
            "content_html": "<h3 id=\"太棒了我终于能写点东西在这个上面了现在这行真的是个markdown的标题新式吗\"><a class=\"markdownIt-Anchor\" href=\"#太棒了我终于能写点东西在这个上面了现在这行真的是个markdown的标题新式吗\">#</a> 太棒了，我终于能写点东西在这个上面了 (现在这行真的是个 markdown 的标题新式吗。。）</h3>\n<p>这感觉真不错，你会喜欢这种感觉的，即使我觉得用 vim 写博客不是个好的体验。。。<br>\n但是。。你也不会特别讨厌这种新奇的东西不是吗？</p>\n",
            "tags": []
        }
    ]
}